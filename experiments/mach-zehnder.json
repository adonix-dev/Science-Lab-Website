{
  "id": "mach-zehnder",
  "title": "Interf√©rom√®tre de Mach-Zehnder",
  "icon": "ü™û",
  "summary": "Un photon est s√©par√© en deux chemins puis recombin√©. Selon la diff√©rence de phase, les interf√©rences dirigent le signal vers une sortie.",
  "introduction": "L'interf√©rom√®tre de Mach-Zehnder est une double fente ferm√©e : deux s√©parateurs de faisceau encadrent des chemins o√π l'on peut introduire un d√©phasage contr√¥l√©.",
  "tags": ["interf√©rence", "phase", "photons"],
  "further": [
    {
      "label": "Universitaire",
      "content": "Apr√®s le premier s√©parateur, l'√©tat du photon est (|A‚ü© + |B‚ü©)/‚àö2. Un d√©phasage ŒîœÜ le transforme en (|A‚ü© + e^{iŒîœÜ}|B‚ü©)/‚àö2 et les probabilit√©s de d√©tection deviennent P‚ÇÅ = cos¬≤(ŒîœÜ/2), P‚ÇÇ = sin¬≤(ŒîœÜ/2)."
    }
  ],
  "animation": {
    "description": "Deux bras optiques repr√©sentant les chemins A et B, avec un curseur de phase qui fait osciller la probabilit√© d'arriv√©e sur les d√©tecteurs.",
    "controls": [
      {
        "id": "phase",
        "label": "D√©phasage ŒîœÜ",
        "type": "range",
        "min": 0,
        "max": 6.283,
        "step": 0.01,
        "value": 1.047,
        "unit": "rad"
      }
    ],
    "parameters": {
      "pulseInterval": 1600
    },
    "sketch": {
      "library": "p5",
      "code": "(() => {\n  return {\n    setup({ state, params }) {\n      state.pulses = [];\n      state.lastPulse = 0;\n      state.interval = params.pulseInterval || 1600;\n    },\n    draw({ p, state, helpers }) {\n      const width = p.width;\n      const height = p.height;\n      const centerY = height / 2;\n      const leftX = width * 0.15;\n      const rightX = width * 0.85;\n      const topY = height * 0.28;\n      const bottomY = height * 0.72;\n      if (!state.lastPulse) {\n        state.lastPulse = p.millis();\n      }\n      p.background(8, 10, 18, 245);\n      p.stroke(58, 215, 255, 120);\n      p.strokeWeight(3);\n      p.noFill();\n      p.line(leftX, centerY, width * 0.32, centerY);\n      p.line(width * 0.32, centerY, width * 0.48, topY);\n      p.line(width * 0.32, centerY, width * 0.48, bottomY);\n      p.line(width * 0.48, topY, width * 0.65, topY);\n      p.line(width * 0.48, bottomY, width * 0.65, bottomY);\n      p.line(width * 0.65, topY, rightX, centerY * 0.7);\n      p.line(width * 0.65, bottomY, rightX, centerY * 1.3);\n      p.fill(58, 215, 255, 200);\n      p.noStroke();\n      p.rect(width * 0.32 - 8, centerY - 35, 16, 70, 6);\n      p.rect(width * 0.65 - 8, topY - 35, 16, 70, 6);\n      const { p1, p2 } = helpers.physics.machZehnderProbabilities(state.phase || 0);\n      const now = p.millis();\n      if (now - state.lastPulse > state.interval) {\n        state.lastPulse = now;\n        state.pulses.push({ t: 0 });\n      }\n      state.pulses.forEach((pulse) => {\n        pulse.t += 0.01;\n      });\n      while (state.pulses.length && state.pulses[0].t > 2) {\n        state.pulses.shift();\n      }\n      p.fill(58, 215, 255);\n      state.pulses.forEach((pulse) => {\n        const progress = Math.min(pulse.t, 1);\n        const x = p.lerp(leftX, width * 0.32, progress);\n        p.circle(x, centerY, 10);\n        if (pulse.t > 0.3 && pulse.t < 1.3) {\n          const branchProgress = Math.min(Math.max(pulse.t - 0.3, 0), 1);\n          const topX = p.lerp(width * 0.32, width * 0.48, branchProgress);\n          const topCurve = p.lerp(centerY, topY, branchProgress);\n          const bottomCurve = p.lerp(centerY, bottomY, branchProgress);\n          p.fill(58, 215, 255, 200);\n          p.circle(topX, topCurve, 8);\n          p.circle(topX, bottomCurve, 8);\n        }\n        if (pulse.t > 1) {\n          const exitProgress = Math.min(pulse.t - 1, 1);\n          const topExitX = p.lerp(width * 0.65, rightX, exitProgress);\n          const bottomExitX = topExitX;\n          const topExitY = p.lerp(topY, centerY * 0.7, exitProgress);\n          const bottomExitY = p.lerp(bottomY, centerY * 1.3, exitProgress);\n          p.fill(58, 215, 255, 160 * p1);\n          p.circle(topExitX, topExitY, 12);\n          p.fill(58, 215, 255, 160 * p2);\n          p.circle(bottomExitX, bottomExitY, 12);\n        }\n      });\n      p.noStroke();\n      p.fill(58, 215, 255, 150);\n      p.rect(rightX - 14, centerY * 0.7 - 20, 28, 40, 6);\n      p.rect(rightX - 14, centerY * 1.3 - 20, 28, 40, 6);\n      p.textAlign(p.RIGHT, p.TOP);\n      p.fill(58, 215, 255, 210);\n      p.textSize(14);\n      p.text(`P‚ÇÅ = ${(p1 * 100).toFixed(0)}%`, rightX - 18, centerY * 0.7 - 50);\n      p.text(`P‚ÇÇ = ${(p2 * 100).toFixed(0)}%`, rightX - 18, centerY * 1.3 - 50);\n      p.textAlign(p.LEFT, p.TOP);\n      p.text(`ŒîœÜ = ${(state.phase || 0).toFixed(2)} rad`, 20, 20);\n    },\n    update({ state, key, value }) {\n      state[key] = value;\n    },\n    replay({ state }) {\n      state.pulses = [];\n      state.lastPulse = 0;\n    }\n  };\n})()"
    }
  }
}
