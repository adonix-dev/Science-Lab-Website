{
  "id": "inegalites-bell",
  "title": "InÃ©galitÃ©s de Bell",
  "icon": "ðŸ“ˆ",
  "summary": "Les tests de Bell comparent les corrÃ©lations quantiques Ã  la limite imposÃ©e par toute thÃ©orie locale.",
  "introduction": "La formulation CHSH des inÃ©galitÃ©s de Bell combine quatre configurations de polariseurs. En mÃ©canique quantique, certaines orientations donnent une valeur S = 2âˆš2, supÃ©rieure Ã  la borne classique S â‰¤ 2.",
  "tags": ["bell", "corrÃ©lation", "non-localitÃ©"],
  "further": [
    {
      "label": "Universitaire",
      "content": "La quantitÃ© CHSH s'exprime S = E(a, b) + E(a, b') + E(a', b) - E(a', b') avec E les corrÃ©lations Â±1. Les modÃ¨les locaux vÃ©rifient |S| â‰¤ 2 alors que les Ã©tats de Bell optimisent S = 2âˆš2 en choisissant des angles sÃ©parÃ©s de 45Â°. Les expÃ©riences modernes ferment progressivement les principales Ã©chappatoires."
    }
  ],
  "animation": {
    "description": "RÃ©glez quatre angles de polariseurs et observez la valeur de S comparÃ©e Ã  la limite classique.",
    "controls": [
      {
        "id": "angleA",
        "label": "a",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 0,
        "unit": "Â°"
      },
      {
        "id": "angleAprime",
        "label": "a'",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 90,
        "unit": "Â°"
      },
      {
        "id": "angleB",
        "label": "b",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 45,
        "unit": "Â°"
      },
      {
        "id": "angleBprime",
        "label": "b'",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 135,
        "unit": "Â°"
      }
    ],
    "parameters": {
      "sampleSize": 400
    },
    "sketch": {
      "library": "p5",
      "code": "(() => {\n  const corrValue = (a, b) => -Math.cos(((a - b) * Math.PI) / 180);\n  return {\n    setup() {},\n    draw({ p, state, helpers }) {\n      const width = p.width;\n      const height = p.height;\n      const angles = {\n        angleA: state.angleA || 0,\n        angleAprime: state.angleAprime || 0,\n        angleB: state.angleB || 0,\n        angleBprime: state.angleBprime || 0\n      };\n      p.background(8, 10, 18, 245);\n      const sValue = helpers.physics.bellCHSH(angles);\n      const correlations = [\n        { label: `E(a, b)`, value: corrValue(angles.angleA, angles.angleB) },\n        { label: `E(a, b')`, value: corrValue(angles.angleA, angles.angleBprime) },\n        { label: `E(a', b)`, value: corrValue(angles.angleAprime, angles.angleB) },\n        { label: `E(a', b')`, value: corrValue(angles.angleAprime, angles.angleBprime) }\n      ];\n      p.noStroke();\n      p.fill(58, 215, 255, 180);\n      p.textAlign(p.LEFT, p.TOP);\n      p.textSize(14);\n      p.text(`S = ${sValue.toFixed(2)}`, 20, 20);\n      p.text('Limite classique |S| â‰¤ 2', 20, 40);\n      const gaugeWidth = width * 0.6;\n      const gaugeX = width * 0.2;\n      const gaugeY = height * 0.2;\n      const gaugeHeight = 12;\n      p.fill(25, 36, 58, 200);\n      p.rect(gaugeX, gaugeY, gaugeWidth, gaugeHeight, 10);\n      const normalized = Math.min(Math.abs(sValue) / (2 * Math.sqrt(2)), 1);\n      p.fill(58, 215, 255, 220);\n      p.rect(gaugeX, gaugeY, gaugeWidth * normalized, gaugeHeight, 10);\n      p.textAlign(p.CENTER, p.TOP);\n      p.text('|S|/2âˆš2', gaugeX + gaugeWidth / 2, gaugeY + 16);\n      const baseX = width * 0.18;\n      const baseY = height * 0.75;\n      const barWidth = width * 0.16;\n      const scale = height * 0.25;\n      correlations.forEach((corr, index) => {\n        const x = baseX + index * (barWidth + 12);\n        const barHeight = corr.value * scale;\n        p.fill(25, 36, 58, 200);\n        p.rect(x, baseY - scale, barWidth, scale * 2, 12);\n        p.fill(58, 215, 255, 200);\n        p.rect(x, baseY, barWidth, -barHeight, 12);\n        p.textAlign(p.CENTER, p.TOP);\n        p.text(`${corr.label} = ${corr.value.toFixed(2)}`, x + barWidth / 2, baseY + 16);\n      });\n      p.stroke(255, 100, 120, 180);\n      p.strokeWeight(2);\n      const classicalX = gaugeX + (Math.min(Math.abs(2) / (2 * Math.sqrt(2)), 1) * gaugeWidth);\n      p.line(classicalX, gaugeY - 6, classicalX, gaugeY + gaugeHeight + 6);\n    },\n    update({ state, key, value }) {\n      state[key] = value;\n    },\n    replay() {}\n  };\n})()"
    }
  }
}
