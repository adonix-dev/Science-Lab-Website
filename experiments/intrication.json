{
  "id": "intrication",
  "title": "Intrication quantique",
  "icon": "ü™ê",
  "summary": "Deux particules peuvent √™tre li√©es de mani√®re telle que la mesure de l‚Äôune d√©termine instantan√©ment l‚Äô√©tat de l‚Äôautre, quelle que soit la distance. Le syst√®me forme un tout indivisible.",
  "introduction": "L'intrication relie deux syst√®mes en un tout unique : mesurer l'un d'eux fixe instantan√©ment le r√©sultat de l'autre selon la base choisie, sans permettre de signaler plus vite que la lumi√®re.",
  "tags": ["corr√©lation", "polariseur", "bell"],
  "further": [
    {
      "label": "Universitaire",
      "content": "Un √©tat singulet de deux spins vaut |Œ®‚Åª‚ü© = (|‚Üë‚Üì‚ü© - |‚Üì‚Üë‚ü©)/‚àö2. Les mesures de spin sur des axes s√©par√©s donnent une corr√©lation -cos(Œ∏_A - Œ∏_B). Les in√©galit√©s de Bell, comme CHSH, sont viol√©es avec une valeur maximale 2‚àö2."
    }
  ],
  "animation": {
    "description": "Deux polariseurs A/B √† angles r√©glables ; tracer corr√©lation cosinus et r√©sultats de co√Øncidences.",
    "controls": [
      {
        "id": "angleA",
        "label": "Polariseur A",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 0,
        "unit": "¬∞"
      },
      {
        "id": "angleB",
        "label": "Polariseur B",
        "type": "range",
        "min": 0,
        "max": 180,
        "step": 1,
        "value": 45,
        "unit": "¬∞"
      }
    ],
    "parameters": {
      "sampleSize": 200
    },
    "sketch": {
      "library": "p5",
      "code": "(() => {\n  const drawPolarizer = (p, center, angle, correlation) => {\n    p.push();\n    p.translate(center.x, center.y);\n    p.rotate((angle * Math.PI) / 180);\n    p.fill(25, 36, 58, 200);\n    p.stroke(58, 215, 255, 160);\n    p.strokeWeight(2);\n    p.rect(-14, -60, 28, 120, 12);\n    p.pop();\n    p.noStroke();\n    p.fill(58, 215, 255, 200);\n    p.circle(center.x, center.y, 18);\n    p.fill(8, 10, 18, 200);\n    p.textAlign(p.CENTER, p.CENTER);\n    p.textSize(12);\n    p.text(correlation > 0 ? '+' : '‚àí', center.x, center.y);\n  };\n  const regenerate = (state, physics) => {\n    state.measurements = [];\n    const correlation = physics.entanglementCorrelation(state.angleA || 0, state.angleB || 0);\n    const sameProb = (correlation + 1) / 2;\n    let sameCount = 0;\n    for (let i = 0; i < state.sampleSize; i += 1) {\n      const same = Math.random() < sameProb;\n      const resultA = Math.random() > 0.5 ? 1 : -1;\n      const resultB = same ? resultA : -resultA;\n      state.measurements.push({ same, a: resultA, b: resultB });\n      if (same) sameCount += 1;\n    }\n    state.sameCount = sameCount;\n    state.diffCount = state.sampleSize - sameCount;\n  };\n  return {\n    setup({ state, params, helpers }) {\n      state.sampleSize = params.sampleSize || 200;\n      regenerate(state, helpers.physics);\n    },\n    draw({ p, state, helpers }) {\n      const width = p.width;\n      const height = p.height;\n      p.background(8, 10, 18, 245);\n      const correlation = helpers.physics.entanglementCorrelation(state.angleA || 0, state.angleB || 0);\n      p.noStroke();\n      p.fill(58, 215, 255, 180);\n      p.textAlign(p.LEFT, p.TOP);\n      p.textSize(14);\n      p.text(`Polariseur A: ${(state.angleA || 0).toFixed(0)}¬∞`, 20, 20);\n      p.text(`Polariseur B: ${(state.angleB || 0).toFixed(0)}¬∞`, 20, 40);\n      p.text(`Corr√©lation ‚ü®A¬∑B‚ü© = ${correlation.toFixed(2)}`, 20, 60);\n      const centerLeft = { x: width * 0.3, y: height * 0.55 };\n      const centerRight = { x: width * 0.7, y: height * 0.55 };\n      drawPolarizer(p, centerLeft, state.angleA || 0, correlation);\n      drawPolarizer(p, centerRight, state.angleB || 0, correlation);\n      p.stroke(58, 215, 255, 120 + Math.abs(correlation) * 80);\n      p.noFill();\n      p.strokeWeight(3);\n      p.bezier(centerLeft.x + 40, centerLeft.y, width * 0.45, height * 0.2, width * 0.55, height * 0.9, centerRight.x - 40, centerRight.y);\n      const radius = Math.min(width, height) * 0.18;\n      state.measurements.slice(0, 120).forEach((m, index) => {\n        const angle = (index / 120) * Math.PI * 2;\n        const r = radius * (0.6 + 0.4 * (m.same ? 1 : 0.6));\n        const x = width * 0.5 + Math.cos(angle) * r;\n        const y = height * 0.55 + Math.sin(angle) * r;\n        const alpha = m.same ? 220 : 120;\n        p.noStroke();\n        p.fill(58, 215, 255, alpha);\n        p.circle(x, y, m.same ? 6 : 4);\n      });\n      p.noStroke();\n      p.fill(58, 215, 255, 180);\n      const barWidth = width * 0.18;\n      const baseY = height * 0.85;\n      const scale = height * 0.25 / state.sampleSize;\n      p.rect(width * 0.25, baseY - state.sameCount * scale, barWidth, state.sameCount * scale, 10);\n      p.rect(width * 0.57, baseY - state.diffCount * scale, barWidth, state.diffCount * scale, 10);\n      p.textAlign(p.CENTER, p.TOP);\n      p.text(`R√©sultats identiques (${state.sameCount})`, width * 0.25 + barWidth / 2, baseY + 8);\n      p.text(`R√©sultats oppos√©s (${state.diffCount})`, width * 0.57 + barWidth / 2, baseY + 8);\n    },\n    update({ state, key, value, helpers }) {\n      state[key] = value;\n      regenerate(state, helpers.physics);\n    },\n    replay({ state, helpers }) {\n      regenerate(state, helpers.physics);\n    }\n  };\n})()"
    }
  }
}
